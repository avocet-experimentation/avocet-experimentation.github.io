---
title: Architecture
description: This section provides a comprehensive overview of Avocet's technical architecture, detailing its core components including feature flags, experiments, environments, and SDK connections.
---

Each Avocet installation is comprised of:
- A MongoDB database for storing
<a href="/content/case-study/appendices/terminology#feature-flag">feature flags</a>,
experiments,
<a href="/content/case-study/appendices/terminology#environment">environments</a>,
and other supporting data.
- An administrative dashboard for managing data stored in Mongo.
- A management API server that lets the dashboard communicate with MongoDB
- A feature flagging API that responds to requests from client applications for feature flag values.
Additionally, Avocet offers two packages:
- An SDK package that allows JavaScript applications to request feature flag values
- A core package with supplementary code used across components.

![Avocet Architecture](/avocet-architecture.png)

## Core Schema

### Feature Flags

Avocet offers `boolean`, `string`, and `number` flag types to accommodate various use cases.

![Feature Flag Types](/feature-flag-types.png)

Flags have a default value, can be toggled on and off per environment (discussed below), and are further customizable through
“<a href="/content/case-study/appendices/terminology#override-rule">override rules</a>”
that override the flag’s default value within a specific environment. The first type of override rule is the “Forced Value” rule.

Forced Value rules set the value for a flag within a single environment. This rule type is useful for changing functionality in ways that cannot be achieved by simply toggling a flag off in an environment (which would cause its value to evaluate to the global fallback, `null`).

![Forced Value Override Rule](/forced-value-override-rule.png)

### Experiments

The other type of override rule is the
<a href="/content/case-study/appendices/terminology#experiment">experiment</a>.
Experiments aim to evaluate how changes in features, design, or functionality affect user behavior, system performance, or other key metrics. 

In Avocet, subjects (users) are randomly assigned to groups, each of which receives a series of treatments. Experimental treatments are defined by one or more pairings of a feature flag and a value to attribute to that flag, and are assigned a lifespan. One or more treatments can be applied to each group; treatments are applied one at a time during the experiment’s life cycle. Once all treatments have elapsed, an experiment ends.

![Experiment Visualization](/experiment-visualization.png)

By allowing multiple flags to be used as independent variables in a single experiment, developers can more easily build experiments testing combinations of features, or controlling for another potentially confounding feature by fixing it to a specified value in all groups.

When defining an experiment, developers can start from A/B or Switchback templates, or build it from scratch. All experiments require at least two treatments to compare against each other. An A/B experiment requires at least two groups, with at least one treatment assigned per group. A switchback experiment requires only one group, but at least two treatments. All treatments will be assigned to the same user group. Typically, treatments should be of equal duration, but this is left to the user to decide. Finally, users can also specify the number of times to repeat the entire sequence of treatments, which is especially useful for switchback tests.

### Environments

In commercial software development processes, it’s common for versions of an application to move through stages, or “environments,” such as “development,” “testing,” and “production.” To support this compartmentalization, Avocet lets users define any number of environments. Override rules customize the behavior of feature flags within a specific environment. This allows developers using Avocet to provide changes in functionality specifically to development teams, testing and QA teams, or any other groups of their choice.

![Environments Visualization](/environments-visualization.png)

### SDK Connections

SDK connections can be created in the dashboard to enable applications to connect to the flagging API via the SDK. When setting up a connection, an API key is generated and provided to the user, who then needs to pass this key in the SDK options. The key is then included in requests to the flagging API, which in turn uses this key to authenticate requests and identify what environment the application is running in. Flag values are determined accordingly.

## Administrative Dashboard

The Admin dashboard is a React application that allows authenticated team members to configure and manage feature flags, experiments, environments, and SDK connections.

For example, users can adjust a flag's value to determine whether it is active or not in a given environment. They can also add rules for flags to customize their behavior on a per-environment basis.

Users can also create experiments either using provided templates for switchback or A/B tests, or build their own free-form. Post-creation, users can continue to make changes such as adding or removing flags, defining new groups, revising treatments, and defining dependent variables.

## Flagging and Management API Servers

Cattails is a Fastify server that mediates all interactions with feature flag, experiment, and environment data, from both the admin dashboard and from client applications when they request flag values.

On the dashboard-facing side, requests are authenticated using Auth0, and database queries occur through a GraphQL layer. 

On the client-facing side, requests are authenticated by the presence of a valid API key, and the flag value returned to the client is determined by attempting to apply any override rules defined on the flag for the client’s environment.

## Database

Avocet stores feature flags, experiments, environments, and client SDK connections in a MongoDB instance that can be deployed onto a dedicated machine. Schema validation and transactions are implemented on cattails via the Mongo driver.
<a href="/content/case-study/engineering-decisions#use-a-document-database">A discussion of why we chose MongoDB</a>.

## Package

Our SDK, offered as a package, permits JavaScript applications to fetch feature flag values from the flagging API. It offers both synchronous and asynchronous flag check methods, each with their own tradeoffs.
<a href="/content/case-study/engineering-decisions#cache-feature-flag-data-on-clients">For more on this, see cache feature flag data on clients</a>.

The core package contains type definitions, Zod schema, and GraphQL schema for setting up the telemetry server. We also have an unpublished package that’s used by the management and flagging APIs to interact with our Mongo database.
